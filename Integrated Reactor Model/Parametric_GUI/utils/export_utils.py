"""
Export Utilities
Handles exporting run configurations to files
"""
import numpy as np
from datetime import datetime


class ExportUtils:
    """Utilities for exporting run configurations"""

    @staticmethod
    def generate_run_dictionaries_content(run_config):
        """Generate the content for run_dictionaries.py file.

        Parameters
        ----------
        run_config : RunConfiguration
            Run configuration object containing simple runs and loop sets

        Returns
        -------
        str
            Python code content for the run_dictionaries.py file
        """
        lines = []

        # Header
        lines.append('"""')
        lines.append('Run dictionaries for parametric studies.')
        lines.append('Each dictionary entry represents a set of parameters to modify from the base inputs.')
        lines.append('Generated by Parametric_GUI')
        lines.append('"""')
        lines.append('import numpy as np')
        lines.append('')

        # Start with default run
        lines.append('# Default run with base inputs')
        lines.append('all_runs = [')
        lines.append('    {')
        lines.append('        "description": "Default inputs"')
        lines.append('    }')

        # Add simple runs
        if run_config.simple_runs:
            lines.append('')
            lines.append('    # Simple parameter runs')
            for i, run in enumerate(run_config.simple_runs):
                lines.append('    ,{')
                # Add description
                if 'description' in run:
                    lines.append(f'        "description": "{run["description"]}",')

                # Add parameters
                param_lines = []
                for param, value in run.items():
                    if param != 'description':
                        param_lines.append(f'        "{param}": {ExportUtils.format_value(value, param)}')

                # Add parameters without trailing comma
                lines.extend([line + ',' for line in param_lines[:-1]])
                if param_lines:
                    lines.append(param_lines[-1])  # Last parameter without comma

                lines.append('    }')

        # Close the simple runs section
        lines.append(']')
        lines.append('')

        # Add loop sets
        if run_config.loop_sets:
            lines.append('# Multi-parameter loops')
            lines.append('# Generate parametric combinations automatically')

            for set_idx, loop_set in enumerate(run_config.loop_sets):
                set_name = loop_set.get('name', f'Loop Set {set_idx + 1}')
                lines.append(f'# Loop set {set_idx + 1}: {set_name}')

                # Extract valid loops
                valid_loops = []
                for loop in loop_set.get('loops', []):
                    # Extract parameter and values
                    param = None
                    values_str = None

                    # Handle both UI elements and stored data
                    if 'param_var' in loop and hasattr(loop['param_var'], 'get'):
                        param = loop['param_var'].get()
                    elif 'param' in loop:
                        param = loop['param']

                    if 'values_var' in loop and hasattr(loop['values_var'], 'get'):
                        values_str = loop['values_var'].get()
                    elif 'values' in loop:
                        values_str = loop['values']

                    if param and values_str:
                        values = ExportUtils.parse_loop_values(values_str)
                        if values:
                            valid_loops.append((param, values))

                if valid_loops:
                    lines.append(f'{set_name.lower().replace(" ", "_")}_params = {{')
                    for i, (param, values) in enumerate(valid_loops):
                        comma = ',' if i < len(valid_loops) - 1 else ''
                        lines.append(f'    "{param}": {ExportUtils.format_value(values, param)}{comma}')
                    lines.append('}')
                    lines.append('')

                    # Generate combinations
                    lines.append(f'# Generate all combinations for {set_name}')
                    lines.append(f'from itertools import product')
                    lines.append(f'{set_name.lower().replace(" ", "_")}_combinations = []')
                    lines.append(f'for combo in product(*{set_name.lower().replace(" ", "_")}_params.values()):')
                    lines.append(f'    run_dict = {{}}')
                    lines.append(f'    for i, (param, value) in enumerate(zip({set_name.lower().replace(" ", "_")}_params.keys(), combo)):')
                    lines.append(f'        run_dict[param] = value')
                    lines.append(f'    # Generate description')
                    lines.append(f'    desc_parts = [f"{{param}} = {{value}}" for param, value in run_dict.items()]')
                    lines.append(f'    run_dict["description"] = " + ".join(desc_parts)')
                    lines.append(f'    {set_name.lower().replace(" ", "_")}_combinations.append(run_dict)')
                    lines.append('')
                    lines.append(f'# Add to all_runs')
                    lines.append(f'all_runs.extend({set_name.lower().replace(" ", "_")}_combinations)')
                    lines.append('')
                else:
                    lines.append(f'# Loop set {set_idx + 1} has no valid configurations')
                    lines.append('')

        return '\n'.join(lines)

    @staticmethod
    def format_value(value, param_name=None):
        """Format a value for Python output with appropriate type casting.

        Parameters
        ----------
        value : Any
            Value to format for Python output
        param_name : str, optional
            Name of the parameter for special formatting rules, by default None

        Returns
        -------
        str
            Formatted value as Python code string
        """
        # Apply type casting for specific parameters
        if param_name in ['particles', 'batches', 'inactive', 'depletion_particles', 'depletion_batches', 'depletion_inactive']:
            if isinstance(value, str):
                return f'int("{value}")'
            else:
                return f'int({value})'
        elif param_name in ['thermal_cutoff', 'fast_cutoff']:
            if isinstance(value, str):
                return f'float("{value}")'
            else:
                return f'float({value})'

        # Default formatting
        if isinstance(value, str):
            return f'"{value}"'
        elif isinstance(value, bool):
            return str(value)
        elif isinstance(value, (list, tuple)):
            # Special handling for depletion timesteps
            if value and isinstance(value[0], dict) and 'steps' in value[0]:
                # Format as multi-line for readability
                formatted_items = []
                for item in value:
                    formatted_items.append(f'{{"steps": {item["steps"]}, "size": {item["size"]}}}')
                return '[\n        ' + ',\n        '.join(formatted_items) + '\n    ]'
            else:
                return str(value)
        elif isinstance(value, np.ndarray):
            return f'np.array({value.tolist()})'
        else:
            return str(value)

    @staticmethod
    def parse_loop_values(values_str):
        """Parse values string into a list of values.

        Parameters
        ----------
        values_str : str
            String containing comma-separated values or Python list

        Returns
        -------
        list
            List of parsed values
        """
        if not values_str:
            return []

        try:
            # Try to evaluate as Python expression first
            values_str = values_str.strip()
            if values_str.startswith('['):
                return eval(values_str)
            else:
                # Parse as comma-separated values
                return [ExportUtils.parse_single_value(v.strip()) for v in values_str.split(',') if v.strip()]
        except:
            # Fallback to string splitting
            return [v.strip() for v in values_str.split(',') if v.strip()]

    @staticmethod
    def parse_single_value(value_str):
        """Parse a single value string.

        Parameters
        ----------
        value_str : str
            String representation of a single value

        Returns
        -------
        Any
            Parsed value (int, float, bool, list, or str)
        """
        value_str = value_str.strip()

        # Try to parse as number
        try:
            if '.' in value_str:
                return float(value_str)
            else:
                return int(value_str)
        except:
            pass

        # Try to parse as boolean
        if value_str.lower() == 'true':
            return True
        elif value_str.lower() == 'false':
            return False

        # Try to parse as list/array
        if value_str.startswith('['):
            try:
                return eval(value_str)
            except:
                pass

        # Return as string
        return value_str
