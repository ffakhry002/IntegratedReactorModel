<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reactor Encoding Visualizations</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .encoding-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .encoding-title {
            font-size: 24px;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .encoding-description {
            color: #666;
            margin-bottom: 20px;
        }
        .visualization-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
        }
        .lattice-grid {
            display: grid;
            grid-template-columns: repeat(8, 40px);
            grid-template-rows: repeat(8, 40px);
            gap: 2px;
            background: #ddd;
            padding: 10px;
            border-radius: 5px;
            position: relative;
        }
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            border: 1px solid #999;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }
        .cell-F { background: #ff9999; color: #333; }
        .cell-C { background: #9999ff; color: white; }
        .cell-I { background: #99ff99; color: #333; }
        .cell-empty { background: #f0f0f0; color: #999; }

        .feature-display {
            flex: 1;
            min-width: 300px;
        }
        .feature-box {
            background: #f8f8f8;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        .feature-title {
            font-weight: bold;
            color: #34495e;
            margin-bottom: 5px;
        }
        .feature-value {
            font-family: monospace;
            color: #666;
        }
        .highlight {
            background: #fffacd !important;
            border: 2px solid #ff6b6b !important;
        }
        .encoding-visual {
            margin-top: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 5px;
        }
        .mini-grid {
            display: inline-grid;
            grid-template-columns: repeat(3, 20px);
            grid-template-rows: repeat(3, 20px);
            gap: 1px;
            background: #ccc;
            padding: 2px;
            margin-right: 10px;
        }
        .mini-cell {
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }
        .graph-viz {
            position: relative;
            width: 320px;
            height: 320px;
            border: 1px solid #ddd;
            background: white;
        }
        .graph-node {
            position: absolute;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
        }
        .graph-node:hover {
            transform: scale(1.2);
            z-index: 100;
        }
        .graph-edge {
            position: absolute;
            background: #666;
            opacity: 0.3;
        }
        .legend {
            margin-top: 10px;
            display: flex;
            gap: 20px;
            font-size: 14px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-box {
            width: 20px;
            height: 20px;
            border: 1px solid #999;
        }
        .center-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 20;
            left: 50%;
            top: 50%;
        }
        .feature-vector-display {
            background: #2c3e50;
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
            margin-top: 10px;
        }
        .vector-segment {
            display: inline-block;
            margin: 0 5px;
            padding: 2px 5px;
            border-radius: 3px;
        }
        .vec-type { background: #e74c3c; }
        .vec-pos { background: #3498db; }
        .vec-cell { background: #2ecc71; }
        .physics-calc {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        .conv-grid {
            display: inline-grid;
            grid-template-columns: repeat(8, 25px);
            grid-template-rows: repeat(8, 25px);
            gap: 1px;
            background: #ccc;
            padding: 5px;
            margin: 10px 0;
        }
        .conv-cell {
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #000;
            border: 1px solid #ddd;
        }
        .conv-highlight {
            background: #ffeb3b !important;
            border: 2px solid #f44336 !important;
        }
        .conv-neighbor {
            background: #e3f2fd !important;
        }
        .edge-info {
            position: absolute;
            font-size: 10px;
            background: white;
            padding: 2px;
            border-radius: 2px;
            pointer-events: none;
        }

        /* Styles for physics visualizations */
        .physics-viz-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .physics-viz-title {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        .viz-canvas {
            background: white;
            padding: 10px;
        }
        .feature-equation {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 10px 0;
            overflow-x: auto;
        }
        .equation-part {
            color: #3498db;
            font-weight: bold;
        }
        .value-highlight {
            color: #2ecc71;
            background: rgba(46, 204, 113, 0.2);
            padding: 2px 4px;
            border-radius: 3px;
        }
        .local-feature-grid {
            display: grid;
            grid-template-columns: repeat(3, 30px);
            grid-template-rows: repeat(3, 30px);
            gap: 2px;
            background: #ddd;
            padding: 5px;
            margin: 10px 0;
        }
        .local-feature-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            border: 1px solid #999;
        }
    </style>
</head>
<body>
    <h1>Reactor Encoding Method Visualizations</h1>

    <!-- Interactive Core Designer -->
    <div class="encoding-section">
        <h2 class="encoding-title">Interactive Core Designer</h2>
        <p class="encoding-description">
            Click to design your own reactor core configuration. All visualizations below will update automatically.
        </p>
        <div style="display: flex; gap: 30px; align-items: flex-start;">
            <div>
                <div class="lattice-grid" id="designer-grid"></div>
                <div class="legend">
                    <div class="legend-item"><div class="legend-box cell-F"></div> Fuel (F)</div>
                    <div class="legend-item"><div class="legend-box cell-C"></div> Coolant (C)</div>
                    <div class="legend-item"><div class="legend-box cell-I"></div> Irradiation (I)</div>
                </div>
                <div style="margin-top: 10px;">
                    <label>Place: </label>
                    <select id="cell-type-selector">
                        <option value="F">Fuel (F)</option>
                        <option value="C">Coolant (C)</option>
                        <option value="I">Irradiation (I)</option>
                    </select>
                    <button onclick="resetToDefault()" style="margin-left: 10px;">Reset to Default</button>
                </div>
            </div>
            <div class="feature-display">
                <div class="feature-box">
                    <div class="feature-title">Current Core Configuration:</div>
                    <div id="core-config-display" style="font-family: monospace; font-size: 12px;"></div>
                </div>
                <div class="feature-box">
                    <div class="feature-title">Show Encoding:</div>
                    <button onclick="showCoreVector('one_hot')" style="margin-right: 5px;">One-Hot</button>
                    <button onclick="showCoreVector('categorical')" style="margin-right: 5px;">Categorical</button>
                    <button onclick="showCoreVector('physics')" style="margin-right: 5px;">Physics</button>
                    <button onclick="showCoreVector('spatial')" style="margin-right: 5px;">Spatial Conv</button>
                    <button onclick="showCoreVector('graph')">Graph-Based</button>
                    <div id="core-vector-display" style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 5px; font-size: 11px; max-height: 200px; overflow-y: auto;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Method 1: One-hot encoding -->
    <div class="encoding-section">
        <h2 class="encoding-title">Method 1: One-hot Encoding with Position Features</h2>
        <p class="encoding-description">
            Encodes each cell type as a 3-bit vector [F, C, I] and adds normalized position features.
            All irradiation positions are encoded identically as [0, 0, 1].
        </p>
        <div class="visualization-container">
            <div>
                <div class="lattice-grid" id="grid1"></div>
                <div class="legend">
                    <div class="legend-item"><div class="legend-box cell-F"></div> Fuel (F)</div>
                    <div class="legend-item"><div class="legend-box cell-C"></div> Coolant (C)</div>
                    <div class="legend-item"><div class="legend-box cell-I"></div> Irradiation (I)</div>
                </div>
                <p style="margin-top: 10px; font-size: 14px; color: #666;">
                    <em>Hover over any cell in the grid to see its individual encoding vector</em>
                </p>
            </div>
            <div class="feature-display">
                <div class="feature-box">
                    <div class="feature-title">Cell Type Encoding:</div>
                    <div class="feature-value">
                        F → [1, 0, 0]<br>
                        C → [0, 1, 0]<br>
                        I* → [0, 0, 1] (all irradiation positions)
                    </div>
                </div>
                <div class="feature-box">
                    <div class="feature-title">Position Features:</div>
                    <div class="feature-value">
                        Each cell gets [row/7, col/7]<br>
                        Example: Cell at (3,4) → [0.43, 0.57]
                    </div>
                </div>
                <div class="feature-box">
                    <div class="feature-title">Individual Cell Vector:</div>
                    <div id="individual-cell-vector" style="font-family: monospace; background: #f0f0f0; padding: 10px; border-radius: 5px; min-height: 60px;">
                        <em>Hover over a cell to see its vector</em>
                    </div>
                </div>
                <div class="feature-box">
                    <div class="feature-title">Total Feature Vector Structure:</div>
                    <div id="feature-vector-viz"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Method 2: Categorical encoding -->
    <div class="encoding-section">
        <h2 class="encoding-title">Method 2: Categorical Encoding with Radial Distance</h2>
        <p class="encoding-description">
            Simple integer encoding for cell types plus radial distance from reactor geometric center at (3.5, 3.5).
            Note: The center (3.5, 3.5) is between cells, not at any fuel position.
        </p>
        <div class="visualization-container">
            <div>
                <div class="lattice-grid" id="grid2"></div>
                <p style="margin-top: 10px; font-size: 14px;">
                    Center at (3.5, 3.5) is between the four middle cells
                </p>
            </div>
            <div class="feature-display">
                <div class="feature-box">
                    <div class="feature-title">Categorical Values:</div>
                    <div class="feature-value">
                        C → 0<br>
                        F → 1<br>
                        I* → 2 (all irradiation positions)<br>
                        Empty → -1
                    </div>
                </div>
                <div class="feature-box">
                    <div class="feature-title">Why Radial Distance from (3.5, 3.5)?</div>
                    <div class="feature-value">
                        • Geometric center of 8×8 grid<br>
                        • Captures symmetry properties<br>
                        • Physics: neutron flux typically peaks at core center<br>
                        • Distance correlates with neutron exposure
                    </div>
                </div>
                <div class="encoding-visual" id="radial-viz"></div>
            </div>
        </div>
    </div>

    <!-- Method 3: Physics-based encoding -->
    <div class="encoding-section">
        <h2 class="encoding-title">Method 3: Physics-based Encoding</h2>
        <p class="encoding-description">
            Combines global configuration features with local physics properties for each irradiation position.
        </p>
        <div class="visualization-container">
            <div>
                <div class="lattice-grid" id="grid3"></div>
            </div>
            <div class="feature-display">
                <!-- Global Features Card -->
                <div class="physics-viz-card">
                    <div class="physics-viz-title">
                        Global Configuration Features
                    </div>
                    <div id="global-physics-viz">
                        <div class="viz-canvas">
                            <canvas id="physics-global-canvas" width="400" height="300"></canvas>
                        </div>
                        <div id="global-feature-controls" style="margin-top: 15px; text-align: center;">
                            <button onclick="showGlobalFeature('distance')" style="margin-right: 10px; padding: 8px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">Average Distance</button>
                            <button onclick="showGlobalFeature('symmetry')" style="padding: 8px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">Symmetry Balance</button>
                        </div>
                        <div id="global-feature-metrics" style="margin-top: 15px;"></div>
                    </div>
                </div>

                <!-- Local Features Card -->
                <div class="physics-viz-card">
                    <div class="physics-viz-title">
                        Local Features per I-position
                    </div>
                    <div id="local-physics-viz">
                        <div style="margin-bottom: 15px;">
                            <label style="font-weight: 600; color: #34495e;">Select I-position: </label>
                            <select id="i-position-selector" onchange="updateLocalFeatures()" style="padding: 6px 12px; border-radius: 5px; border: 1px solid #bdc3c7;">
                            </select>
                            <button onclick="refreshLocalFeatures()" style="margin-left: 10px; padding: 6px 15px; background: #2ecc71; color: white; border: none; border-radius: 5px; cursor: pointer;">Refresh</button>
                        </div>
                        <div class="viz-canvas">
                            <canvas id="physics-local-canvas" width="650" height="280"></canvas>
                        </div>
                        <div id="local-feature-metrics" style="margin-top: 15px;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Method 4: Spatial convolution encoding -->
    <div class="encoding-section">
        <h2 class="encoding-title">Method 4: Spatial Convolution Encoding</h2>
        <p class="encoding-description">
            Encodes each cell with its 3×3 neighborhood pattern, capturing local spatial context.
        </p>
        <div class="visualization-container">
            <div>
                <h4>Interactive Grid - Hover to see neighborhoods</h4>
                <div class="conv-grid" id="conv-interactive"></div>
            </div>
            <div class="feature-display">
                <div class="feature-box">
                    <div class="feature-title">How it works:</div>
                    <div class="feature-value">
                        1. For each cell in the 8×8 grid<br>
                        2. Extract its 3×3 neighborhood (with padding)<br>
                        3. Encode each of the 9 cells as [C, F, I, X]<br>
                        4. Result: 64 cells × 9 neighbors × 4 bits = 2,304 features
                    </div>
                </div>
                <div class="encoding-visual">
                    <div id="conv-examples"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Method 5: Graph-based encoding -->
    <div class="encoding-section">
        <h2 class="encoding-title">Method 5: Graph-based Encoding</h2>
        <p class="encoding-description">
            Treats the reactor as a graph where cells are nodes connected to adjacent cells.
        </p>
        <div class="visualization-container">
            <div>
                <h4>Interactive Graph - Hover nodes to see connections</h4>
                <div class="graph-viz" id="graph-viz"></div>
            </div>
            <div class="feature-display">
                <div class="feature-box">
                    <div class="feature-title">Graph Features per Node:</div>
                    <div id="graph-feature-detail"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Sample reactor lattice - I3 moved to edge
        let lattice = [
            ['C', 'C', 'F', 'F', 'F', 'F', 'C', 'C'],
            ['C', 'F', 'F', 'I1', 'F', 'F', 'I3', 'C'],
            ['F', 'F', 'F', 'F', 'F', 'F', 'F', 'F'],
            ['F', 'I2', 'F', 'F', 'F', 'F', 'F', 'F'],
            ['F', 'F', 'F', 'F', 'F', 'F', 'F', 'F'],
            ['F', 'F', 'F', 'F', 'F', 'F', 'F', 'F'],
            ['C', 'F', 'F', 'F', 'I4', 'F', 'F', 'C'],
            ['C', 'C', 'F', 'F', 'F', 'F', 'C', 'C']
        ];

        // Default lattice for reset
        const defaultLattice = [
            ['C', 'C', 'F', 'F', 'F', 'F', 'C', 'C'],
            ['C', 'F', 'F', 'I1', 'F', 'F', 'I3', 'C'],
            ['F', 'F', 'F', 'F', 'F', 'F', 'F', 'F'],
            ['F', 'I2', 'F', 'F', 'F', 'F', 'F', 'F'],
            ['F', 'F', 'F', 'F', 'F', 'F', 'F', 'F'],
            ['F', 'F', 'F', 'F', 'F', 'F', 'F', 'F'],
            ['C', 'F', 'F', 'F', 'I4', 'F', 'F', 'C'],
            ['C', 'C', 'F', 'F', 'F', 'F', 'C', 'C']
        ];

        // Create basic grid
        function createGrid(gridId, showCenter = false, interactive = false) {
            const grid = document.getElementById(gridId);
            grid.innerHTML = '';

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const cell = document.createElement('div');
                    const cellType = lattice[i][j];
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;

                    if (cellType === 'F') {
                        cell.classList.add('cell-F');
                        cell.textContent = 'F';
                    } else if (cellType === 'C') {
                        cell.classList.add('cell-C');
                        cell.textContent = 'C';
                    } else if (cellType.startsWith('I')) {
                        cell.classList.add('cell-I');
                        cell.textContent = 'I';
                    } else {
                        cell.classList.add('cell-empty');
                        cell.textContent = '·';
                    }

                    cell.title = `Position (${i}, ${j})`;

                    // Add hover functionality for Method 1 (one-hot encoding)
                    if (gridId === 'grid1') {
                        cell.addEventListener('mouseenter', () => {
                            showIndividualCellVector(i, j, cellType);
                        });
                        cell.addEventListener('mouseleave', () => {
                            document.getElementById('individual-cell-vector').innerHTML = '<em>Hover over a cell to see its vector</em>';
                        });
                    }

                    // Add click functionality for designer grid
                    if (interactive) {
                        cell.addEventListener('click', () => {
                            const selectedType = document.getElementById('cell-type-selector').value;
                            placeCellType(i, j, selectedType);
                        });
                    }

                    grid.appendChild(cell);
                }
            }

            if (showCenter) {
                // Center marker is handled in CSS
            }
        }

        // Create all basic grids
        createGrid('grid1');
        createGrid('grid2', true);
        createGrid('grid3');

        // Create feature vector visualization for Method 1
        function createFeatureVectorViz() {
            const viz = document.getElementById('feature-vector-viz');
            viz.innerHTML = `
                <div class="feature-vector-display">
                    <div style="margin-bottom: 10px;">Feature vector layout (320 total values):</div>
                    <div>
                        <span class="vector-segment vec-type">[Cell types: 64×3 = 192 values]</span>
                        <span class="vector-segment vec-pos">[Positions: 64×2 = 128 values]</span>
                    </div>
                    <div style="margin-top: 10px; font-size: 11px;">
                        First 15 values: [1,0,0, 1,0,0, 0,1,0, 0,1,0, 0,1,0...] (cell types)<br>
                        After all cell types: [0/7,0/7, 0/7,1/7, 0/7,2/7...] (positions)
                    </div>
                </div>
            `;
        }
        createFeatureVectorViz();

        // Create improved radial distance visualization for Method 2
        function createRadialViz() {
            const viz = document.getElementById('radial-viz');
            viz.innerHTML = ''; // Clear previous content

            const canvas = document.createElement('canvas');
            canvas.width = 320;
            canvas.height = 320;
            viz.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            const cellSize = 40;

            // Draw cells with radial distance values
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const x = j * cellSize;
                    const y = i * cellSize;

                    // Calculate distance from cell center to grid center
                    const cellCenterX = i;  // row
                    const cellCenterY = j;  // col
                    const dist = Math.sqrt(Math.pow(cellCenterX - 3.5, 2) + Math.pow(cellCenterY - 3.5, 2));
                    const maxDist = 3.5 * Math.sqrt(2);
                    const normalizedDist = dist / maxDist;

                    // Color based on distance
                    const intensity = Math.floor((1 - normalizedDist) * 255);
                    ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${255})`;
                    ctx.fillRect(x, y, cellSize - 2, cellSize - 2);

                    // Draw distance value
                    ctx.fillStyle = normalizedDist < 0.5 ? 'white' : 'black';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(normalizedDist.toFixed(2), x + cellSize/2, y + cellSize/2);
                }
            }

            // Draw center marker at grid intersection
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(4 * cellSize, 4 * cellSize, 4, 0, 2 * Math.PI);
            ctx.fill();

            const label = document.createElement('div');
            label.style.marginTop = '10px';
            label.innerHTML = `
                <strong>Radial distance from center (3.5, 3.5)</strong><br>
                Values show normalized distance (0 = center, 1 = corner)<br>
                Center is between cells, capturing reactor symmetry
            `;
            viz.appendChild(label);
        }
        createRadialViz();

        // Create interactive physics visualizations for Method 3
        let currentGlobalFeature = 'distance';
        let currentLocalPosition = [1, 3];

        function createPhysicsVisualizations() {
            updateIPositionSelector();
            showGlobalFeature('distance');
            updateLocalFeatures();
        }

        function updateIPositionSelector() {
            const selector = document.getElementById('i-position-selector');
            selector.innerHTML = '';

            const iPositions = [];
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (lattice[i][j].startsWith('I')) {
                        iPositions.push({row: i, col: j, label: lattice[i][j]});
                    }
                }
            }

            if (iPositions.length === 0) {
                selector.innerHTML = '<option value="">No I positions</option>';
                return;
            }

            iPositions.forEach((pos, index) => {
                const option = document.createElement('option');
                option.value = `${pos.row},${pos.col}`;
                option.textContent = `${pos.label} at (${pos.row},${pos.col})`;
                if (index === 0) option.selected = true;
                selector.appendChild(option);
            });
        }

        function showGlobalFeature(feature) {
            currentGlobalFeature = feature;
            const canvas = document.getElementById('physics-global-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const scale = 35;
            const offsetX = 50;
            const offsetY = 40;

            // Draw grid background
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(offsetX, offsetY, 8 * scale, 8 * scale);

            // Draw grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 8; i++) {
                ctx.beginPath();
                ctx.moveTo(offsetX + i * scale, offsetY);
                ctx.lineTo(offsetX + i * scale, offsetY + 8 * scale);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(offsetX, offsetY + i * scale);
                ctx.lineTo(offsetX + 8 * scale, offsetY + i * scale);
                ctx.stroke();
            }

            // Draw cells with better styling
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const cellType = lattice[i][j];
                    const x = offsetX + j * scale;
                    const y = offsetY + i * scale;

                    ctx.save();
                    ctx.shadowColor = 'rgba(0,0,0,0.1)';
                    ctx.shadowBlur = 3;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;

                    if (cellType === 'F') {
                        ctx.fillStyle = '#ff9999';
                        ctx.fillRect(x + 3, y + 3, scale - 6, scale - 6);
                    } else if (cellType === 'C') {
                        ctx.fillStyle = '#9999ff';
                        ctx.fillRect(x + 3, y + 3, scale - 6, scale - 6);
                    }
                    ctx.restore();
                }
            }

            // Get I-positions
            const iPositions = [];
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (lattice[i][j].startsWith('I')) {
                        iPositions.push({
                            row: i,
                            col: j,
                            x: j + 0.5,
                            y: i + 0.5,
                            label: lattice[i][j]
                        });
                    }
                }
            }

            // Draw I-positions with better styling
            iPositions.forEach((pos, idx) => {
                const x = offsetX + pos.col * scale;
                const y = offsetY + pos.row * scale;

                ctx.save();
                ctx.shadowColor = 'rgba(0,0,0,0.2)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.fillStyle = '#99ff99';
                ctx.fillRect(x + 3, y + 3, scale - 6, scale - 6);
                ctx.restore();

                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`I${idx + 1}`, x + scale/2, y + scale/2 + 5);
            });

            // True geometric center
            const centerX = offsetX + 4.0 * scale;
            const centerY = offsetY + 4.0 * scale;

            const metricsDiv = document.getElementById('global-feature-metrics');

            if (feature === 'distance') {
                // Draw lines from each I to center with better styling
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.lineCap = 'round';

                let totalDist = 0;
                const distances = [];
                iPositions.forEach((pos, idx) => {
                    const posX = offsetX + pos.x * scale;
                    const posY = offsetY + pos.y * scale;

                    ctx.beginPath();
                    ctx.moveTo(posX, posY);
                    ctx.lineTo(centerX, centerY);
                    ctx.stroke();

                    const dist = Math.sqrt(Math.pow(pos.x - 4, 2) + Math.pow(pos.y - 4, 2));
                    distances.push(dist);
                    totalDist += dist;

                    // Draw distance label with background
                    const midX = (posX + centerX) / 2;
                    const midY = (posY + centerY) / 2;

                    ctx.save();
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.fillRect(midX - 15, midY - 10, 30, 16);
                    ctx.fillStyle = '#3498db';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(dist.toFixed(2), midX, midY + 3);
                    ctx.restore();
                });
                ctx.setLineDash([]);

                // Draw center with better styling
                ctx.save();
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 4;
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();

                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.fillText('Center (4,4)', centerX - 30, centerY + 20);

                const avgDist = iPositions.length > 0 ? totalDist / iPositions.length : 0;
                const maxDist = Math.sqrt(2) * 4.0;
                const normalized = avgDist / maxDist;

                metricsDiv.innerHTML = `
                    <div class="feature-equation">
                        <div style="margin-bottom: 10px;">Average Distance to Core Center:</div>
                        <div>d̄ = (${distances.map(d => d.toFixed(2)).join(' + ')}) / ${iPositions.length} = <span class="value-highlight">${avgDist.toFixed(3)}</span></div>
                        <div style="margin-top: 5px;">Normalized: ${avgDist.toFixed(3)} / ${maxDist.toFixed(3)} = <span class="value-highlight">${normalized.toFixed(3)}</span></div>
                    </div>
                `;

            } else if (feature === 'symmetry') {
                // Calculate center of mass
                let sumX = 0, sumY = 0;
                iPositions.forEach(pos => {
                    sumX += pos.x;
                    sumY += pos.y;
                });
                const comX = iPositions.length > 0 ? sumX / iPositions.length : 4.0;
                const comY = iPositions.length > 0 ? sumY / iPositions.length : 4.0;
                const comPixelX = offsetX + comX * scale;
                const comPixelY = offsetY + comY * scale;

                // Draw lines from each I to CoM with better styling
                ctx.strokeStyle = 'rgba(46, 204, 113, 0.6)';
                ctx.lineWidth = 3;
                ctx.setLineDash([6, 4]);
                iPositions.forEach(pos => {
                    const posX = offsetX + pos.x * scale;
                    const posY = offsetY + pos.y * scale;
                    ctx.beginPath();
                    ctx.moveTo(posX, posY);
                    ctx.lineTo(comPixelX, comPixelY);
                    ctx.stroke();
                });
                ctx.setLineDash([]);

                // Draw center of mass with better styling
                ctx.save();
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 4;
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(comPixelX, comPixelY, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('CoM', comPixelX, comPixelY + 3);
                ctx.restore();

                // Draw reactor center
                ctx.save();
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 4;
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();

                // Draw distance between CoM and center with better styling
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(comPixelX, comPixelY);
                ctx.lineTo(centerX, centerY);
                ctx.stroke();
                ctx.setLineDash([]);

                const symmetryDist = Math.sqrt(Math.pow(comX - 4.0, 2) + Math.pow(comY - 4.0, 2));
                const maxDist = Math.sqrt(2) * 4.0;
                const normalized = symmetryDist / maxDist;

                // Draw symmetry distance label - offset to the side
                const midX = (comPixelX + centerX) / 2;
                const midY = (comPixelY + centerY) / 2;

                // Calculate perpendicular offset
                const dx = centerX - comPixelX;
                const dy = centerY - comPixelY;
                const len = Math.sqrt(dx * dx + dy * dy);
                let labelOffsetX = 0;
                let labelOffsetY = -25; // Default above

                if (len > 0.1) {
                    // Calculate perpendicular direction
                    labelOffsetX = -dy / len * 30;
                    labelOffsetY = dx / len * 30;
                }

                ctx.save();
                ctx.fillStyle = 'rgba(255,255,255,0.95)';
                ctx.fillRect(midX + labelOffsetX - 20, midY + labelOffsetY - 8, 40, 16);
                ctx.fillStyle = '#e74c3c';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(symmetryDist.toFixed(3), midX + labelOffsetX, midY + labelOffsetY + 5);
                ctx.restore();

                metricsDiv.innerHTML = `
                    <div class="feature-equation">
                        <div style="margin-bottom: 10px;">Symmetry Balance (Center of Mass):</div>
                        <div>CoM = ((${sumX.toFixed(1)})/${iPositions.length}, (${sumY.toFixed(1)})/${iPositions.length}) = <span class="value-highlight">(${comX.toFixed(2)}, ${comY.toFixed(2)})</span></div>
                        <div style="margin-top: 5px;">Distance from CoM to center = <span class="value-highlight">${symmetryDist.toFixed(3)}</span></div>
                        <div style="margin-top: 5px;">Normalized: ${symmetryDist.toFixed(3)} / ${maxDist.toFixed(3)} = <span class="value-highlight">${normalized.toFixed(3)}</span></div>
                        <div style="margin-top: 10px; font-style: italic;">Lower values indicate better symmetry</div>
                    </div>
                `;
            }
        }

        function updateLocalFeatures() {
            const selector = document.getElementById('i-position-selector');
            if (!selector.value || selector.value === '') {
                const metricsDiv = document.getElementById('local-feature-metrics');
                metricsDiv.innerHTML = '<div style="font-style: italic; color: #666;">No irradiation positions available. Add some I positions in the designer above.</div>';
                return;
            }

            const [row, col] = selector.value.split(',').map(Number);
            currentLocalPosition = [row, col];

            const canvas = document.getElementById('physics-local-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const metricsDiv = document.getElementById('local-feature-metrics');

            // Calculate all local features according to the Python code
            const features = computeLocalFeaturesFromPython(row, col);

            // Feature 1: Local Fuel Density (3x3 neighborhood)
            const nScale = 35;
            const nOffsetX = 20;
            const nOffsetY = 20;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('1. Local Fuel Density', nOffsetX, nOffsetY - 5);

            let fuelCount = 0;
            for (let di = -1; di <= 1; di++) {
                for (let dj = -1; dj <= 1; dj++) {
                    const ni = row + di;
                    const nj = col + dj;
                    const x = nOffsetX + (dj + 1) * nScale;
                    const y = nOffsetY + (di + 1) * nScale;

                    if (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {
                        const cellType = lattice[ni][nj];
                        if (cellType === 'F') {
                            ctx.fillStyle = '#ff9999';
                            fuelCount++;
                        } else if (cellType === 'C') {
                            ctx.fillStyle = '#9999ff';
                        } else if (cellType.startsWith('I')) {
                            ctx.fillStyle = '#99ff99';
                        }
                        ctx.fillRect(x, y, nScale - 2, nScale - 2);

                        ctx.fillStyle = '#333';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(cellType[0], x + nScale/2, y + nScale/2 + 5);
                    } else {
                        ctx.fillStyle = '#ddd';
                        ctx.fillRect(x, y, nScale - 2, nScale - 2);
                        ctx.fillStyle = '#999';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('×', x + nScale/2, y + nScale/2 + 5);
                    }

                    // Highlight center
                    if (di === 0 && dj === 0) {
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x, y, nScale - 2, nScale - 2);
                    }
                }
            }

            // Display fuel density value
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Density: ${features.fuelDensity.toFixed(3)}`, nOffsetX + nScale * 1.5, nOffsetY + nScale * 3 + 20);

            // Feature 2: Coolant Contact (3x3 neighborhood showing coolant)
            const coolantOffsetX = 170;
            const coolantOffsetY = 20;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('2. Coolant Contact', coolantOffsetX, coolantOffsetY - 5);

            // Draw 3x3 grid showing coolant cells
            for (let di = -1; di <= 1; di++) {
                for (let dj = -1; dj <= 1; dj++) {
                    const ni = row + di;
                    const nj = col + dj;
                    const x = coolantOffsetX + (dj + 1) * nScale;
                    const y = coolantOffsetY + (di + 1) * nScale;

                    // Highlight adjacent cells (not diagonal)
                    const isAdjacent = (Math.abs(di) + Math.abs(dj)) === 1;

                    if (ni < 0 || ni >= 8 || nj < 0 || nj >= 8) {
                        // Outside grid - virtual coolant
                        ctx.fillStyle = isAdjacent ? '#6666ff' : '#ddd';
                        ctx.fillRect(x, y, nScale - 2, nScale - 2);
                        if (isAdjacent) {
                            ctx.fillStyle = 'white';
                            ctx.font = '14px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('C', x + nScale/2, y + nScale/2 + 5);
                        }
                    } else {
                        const cellType = lattice[ni][nj];
                        if (cellType === 'C' && isAdjacent) {
                            ctx.fillStyle = '#6666ff';
                        } else if (cellType === 'C') {
                            ctx.fillStyle = '#9999ff';
                        } else if (cellType === 'F') {
                            ctx.fillStyle = '#ffcccc';
                        } else if (cellType.startsWith('I')) {
                            ctx.fillStyle = '#ccffcc';
                        } else {
                            ctx.fillStyle = '#f0f0f0';
                        }
                        ctx.fillRect(x, y, nScale - 2, nScale - 2);

                        ctx.fillStyle = cellType === 'C' && isAdjacent ? 'white' : '#333';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(cellType[0], x + nScale/2, y + nScale/2 + 5);
                    }

                    // Highlight center
                    if (di === 0 && dj === 0) {
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x, y, nScale - 2, nScale - 2);
                    }
                }
            }

            // Display coolant contact value
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Contact: ${features.coolantContact.toFixed(3)}`, coolantOffsetX + nScale * 1.5, coolantOffsetY + nScale * 3 + 20);

            // Feature 3: NCI (Neutron Competition Index) - moved to the right
            const nciOffsetX = 320;
            const nciOffsetY = 20;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('3. NCI', nciOffsetX, nciOffsetY - 5);

            // Get all I-positions
            const iPositions = [];
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (lattice[i][j].startsWith('I')) {
                        iPositions.push({
                            row: i,
                            col: j,
                            x: j + 0.5,
                            y: i + 0.5,
                            label: lattice[i][j]
                        });
                    }
                }
            }

            // Draw mini grid showing all I positions - make it bigger
            const nciScale = 30;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const cellType = lattice[i][j];
                    const x = nciOffsetX + j * nciScale;
                    const y = nciOffsetY + i * nciScale;

                    if (cellType === 'F') {
                        ctx.fillStyle = '#ffcccc';
                    } else if (cellType === 'C') {
                        ctx.fillStyle = '#ccccff';
                    } else if (cellType.startsWith('I')) {
                        ctx.fillStyle = '#ccffcc';
                    } else {
                        ctx.fillStyle = '#f0f0f0';
                    }
                    ctx.fillRect(x, y, nciScale - 1, nciScale - 1);
                }
            }

            // Calculate NCI for current position
            const currentPos = {x: col + 0.5, y: row + 0.5};
            let nci = 0;
            const lambda = 1.5;
            const threshold_low = Math.sqrt(4.9);
            const threshold_high = Math.sqrt(5.1);

            // Highlight current position
            ctx.fillStyle = '#99ff99';
            ctx.fillRect(nciOffsetX + col * nciScale, nciOffsetY + row * nciScale, nciScale - 1, nciScale - 1);

            // Draw connections to other I positions and calculate NCI
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);

            let nciComponents = [];
            for (let otherPos of iPositions) {
                if (otherPos.row === row && otherPos.col === col) continue;

                const distance = Math.sqrt(Math.pow(currentPos.x - otherPos.x, 2) + Math.pow(currentPos.y - otherPos.y, 2));
                let contribution = 0;

                if (distance < threshold_low) {
                    contribution = Math.exp(-distance / lambda);
                } else if (distance <= threshold_high) {
                    contribution = 0.1;
                }

                nci += contribution;
                nciComponents.push({pos: otherPos, dist: distance, contrib: contribution});

                // Draw line to other I position
                const fromX = nciOffsetX + col * nciScale + nciScale/2;
                const fromY = nciOffsetY + row * nciScale + nciScale/2;
                const toX = nciOffsetX + otherPos.col * nciScale + nciScale/2;
                const toY = nciOffsetY + otherPos.row * nciScale + nciScale/2;

                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.stroke();

                // Draw distance and contribution label
                const midX = (fromX + toX) / 2;
                const midY = (fromY + toY) / 2;

                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillRect(midX - 25, midY - 12, 50, 20);

                ctx.fillStyle = '#9b59b6';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`d=${distance.toFixed(1)}`, midX, midY - 2);
                ctx.fillText(`${contribution.toFixed(3)}`, midX, midY + 8);
            }
            ctx.setLineDash([]);

            // Display NCI value
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`NCI: ${nci.toFixed(3)}`, nciOffsetX + nciScale * 4, nciOffsetY + nciScale * 8 + 15);

            // Draw feature equations and values - bring it much closer
            metricsDiv.innerHTML = `
                <div class="feature-equation" style="margin-top: 5px;">
                    <strong>Local Features for I at (${row}, ${col}):</strong><br><br>

                    1. <strong>Fuel Density:</strong> ${features.fuelCount}/8 neighbors are fuel<br>
                    &nbsp;&nbsp;&nbsp;Value = ${features.fuelCount}/8 = <span class="value-highlight">${features.fuelDensity.toFixed(3)}</span><br><br>

                    2. <strong>Coolant Contact:</strong> ${features.coolantCount} adjacent coolant cells (normalized by 2)<br>
                    &nbsp;&nbsp;&nbsp;Value = ${features.coolantCount}/2 = <span class="value-highlight">${features.coolantContact.toFixed(3)}</span><br><br>

                    3. <strong>Edge Distance:</strong> min(${row}, ${col}, ${7-row}, ${7-col}) = ${features.edgeDist}<br>
                    &nbsp;&nbsp;&nbsp;Normalized = ${features.edgeDist}/3.5 = <span class="value-highlight">${features.edgeDistNorm.toFixed(3)}</span><br><br>

                    4. <strong>Core Distance:</strong> √((${row}.5-4)² + (${col}.5-4)²) = ${features.centerDist.toFixed(3)}<br>
                    &nbsp;&nbsp;&nbsp;Normalized = ${features.centerDist.toFixed(3)}/${features.maxDist.toFixed(3)} = <span class="value-highlight">${features.centerDistNorm.toFixed(3)}</span><br><br>

                    5. <strong>NCI:</strong> Σ contribution from other I-positions<br>
                    ${nciComponents.map(c => `&nbsp;&nbsp;&nbsp;d(${c.pos.label})=${c.dist.toFixed(1)} → ${c.contrib < 0.001 ? '0' : c.contrib.toFixed(3)}`).join('<br>')}<br>
                    &nbsp;&nbsp;&nbsp;Total NCI = <span class="value-highlight">${nci.toFixed(3)}</span><br><br>

                    <strong>Complete feature vector:</strong><br>
                    [${features.fuelDensity.toFixed(3)}, ${features.coolantContact.toFixed(3)}, ${features.edgeDistNorm.toFixed(3)}, ${features.centerDistNorm.toFixed(3)}, ${nci.toFixed(3)}]
                </div>
            `;
        }

        // Compute local features exactly as in Python code
        function computeLocalFeaturesFromPython(row, col) {
            // Position center for distance calculations
            const posCenter = [row + 0.5, col + 0.5];
            const reactorCenter = [4.0, 4.0];

            // 1. Local fuel density (8 neighbors including diagonals)
            let fuelCount = 0;
            const neighbors = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
            for (let [di, dj] of neighbors) {
                const ni = row + di;
                const nj = col + dj;
                if (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {
                    if (lattice[ni][nj] === 'F') {  // Only count F, not I
                        fuelCount++;
                    }
                }
            }
            const localFuelDensity = fuelCount / 8;

            // 2. Coolant contact count (4 adjacent cells)
            const specialPositions = [[1,2], [2,1], [5,1], [6,2], [6,5], [5,6], [2,6], [1,5]];
            let coolantContactNorm;

            // Check if current position is in special positions
            const isSpecial = specialPositions.some(([r, c]) => r === row && c === col);

            if (isSpecial) {
                coolantContactNorm = 0.0;
            } else {
                let coolantCount = 0;
                const adjacentOffsets = [[-1, 0], [1, 0], [0, -1], [0, 1]];  // up, down, left, right

                for (let [di, dj] of adjacentOffsets) {
                    const ni = row + di;
                    const nj = col + dj;

                    if (ni < 0 || ni > 7 || nj < 0 || nj > 7) {
                        // Outside grid boundary counts as coolant
                        coolantCount++;
                    } else if (lattice[ni][nj] === 'C') {
                        coolantCount++;
                    }
                }
                coolantContactNorm = coolantCount / 2.0;
            }

            // 3. Edge distance
            const edgeDist = Math.min(row, col, 7 - row, 7 - col);
            const edgeDistNorm = edgeDist / 3.5;

            // 4. Distance to core center
            const centerDist = Math.sqrt(
                Math.pow(posCenter[0] - reactorCenter[0], 2) +
                Math.pow(posCenter[1] - reactorCenter[1], 2)
            );
            const maxDist = Math.sqrt(2) * 4;
            const centerDistNorm = centerDist / maxDist;

            return {
                fuelCount,
                fuelDensity: localFuelDensity,
                coolantCount: coolantContactNorm * 2,  // For display
                coolantContact: coolantContactNorm,
                edgeDist,
                edgeDistNorm,
                centerDist,
                maxDist,
                centerDistNorm
            };
        }

        // Compute NCI exactly as in Python code
        function computeNCIForPosition(row, col) {
            // Get all I-positions
            const iPositions = [];
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (lattice[i][j].startsWith('I')) {
                        iPositions.push({
                            row: i,
                            col: j,
                            x: j + 0.5,
                            y: i + 0.5
                        });
                    }
                }
            }

            // Current position in continuous coordinates
            const currentPos = {x: col + 0.5, y: row + 0.5};

            // NCI calculation with thresholds from Python code
            const lambda = 1.5;
            const thresholdLow = Math.sqrt(4.9);   // ~2.21
            const thresholdHigh = Math.sqrt(5.1);  // ~2.26

            let nci = 0.0;
            for (let otherPos of iPositions) {
                if (otherPos.row === row && otherPos.col === col) continue;  // Skip self

                const dist = Math.sqrt(
                    Math.pow(currentPos.x - otherPos.x, 2) +
                    Math.pow(currentPos.y - otherPos.y, 2)
                );

                if (dist < thresholdLow) {
                    nci += Math.exp(-dist / lambda);
                } else if (dist <= thresholdHigh) {
                    nci += 0.1;
                }
                // else: dist > thresholdHigh, contributes 0
            }

            return nci;
        }

        createPhysicsVisualizations();

        // Function to refresh local features
        function refreshLocalFeatures() {
            updateIPositionSelector();
            const selector = document.getElementById('i-position-selector');
            if (selector.value && selector.value !== '') {
                updateLocalFeatures();
            } else {
                document.getElementById('local-feature-metrics').innerHTML = '<div class="interactive-hint">No irradiation positions available. Add some I positions in the designer above.</div>';
            }
            showGlobalFeature(currentGlobalFeature);
        }

        // Make functions globally available
        window.showGlobalFeature = showGlobalFeature;
        window.updateLocalFeatures = updateLocalFeatures;
        window.refreshLocalFeatures = refreshLocalFeatures;

        // Create interactive convolution visualization for Method 4
        function createConvInteractive() {
            const grid = document.getElementById('conv-interactive');
            grid.innerHTML = '';

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const cell = document.createElement('div');
                    const cellType = lattice[i][j];
                    cell.className = 'conv-cell';

                    if (cellType === 'F') {
                        cell.style.background = '#ff9999';
                        cell.style.color = '#000';
                        cell.textContent = 'F';
                    } else if (cellType === 'C') {
                        cell.style.background = '#9999ff';
                        cell.style.color = '#000';
                        cell.textContent = 'C';
                    } else if (cellType.startsWith('I')) {
                        cell.style.background = '#99ff99';
                        cell.style.color = '#000';
                        cell.textContent = 'I';
                    }

                    // Add hover effect
                    cell.addEventListener('mouseenter', () => {
                        // Clear previous highlights
                        document.querySelectorAll('.conv-highlight, .conv-neighbor').forEach(el => {
                            el.classList.remove('conv-highlight', 'conv-neighbor');
                        });

                        // Highlight current cell
                        cell.classList.add('conv-highlight');

                        // Highlight 3x3 neighborhood
                        for (let di = -1; di <= 1; di++) {
                            for (let dj = -1; dj <= 1; dj++) {
                                if (di === 0 && dj === 0) continue;
                                const ni = i + di;
                                const nj = j + dj;
                                if (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {
                                    const idx = ni * 8 + nj;
                                    grid.children[idx].classList.add('conv-neighbor');
                                }
                            }
                        }

                        // Update example display
                        updateConvExample(i, j);
                    });

                    grid.appendChild(cell);
                }
            }
        }

        function updateConvExample(i, j) {
            const examples = document.getElementById('conv-examples');
            let neighborhood = [];

            // Get 3x3 neighborhood with padding
            for (let di = -1; di <= 1; di++) {
                for (let dj = -1; dj <= 1; dj++) {
                    const ni = i + di;
                    const nj = j + dj;
                    if (ni < 0 || ni >= 8 || nj < 0 || nj >= 8) {
                        neighborhood.push('X');
                    } else {
                        const cell = lattice[ni][nj];
                        if (cell === 'F') neighborhood.push('F');
                        else if (cell === 'C') neighborhood.push('C');
                        else if (cell.startsWith('I')) neighborhood.push('I');
                        else neighborhood.push('·');
                    }
                }
            }

            examples.innerHTML = `
                <strong>Neighborhood for cell (${i},${j}):</strong><br>
                <div style="display: flex; align-items: center; gap: 20px; margin-top: 10px;">
                    <div class="mini-grid">
                        ${neighborhood.map((cell, idx) => {
                            let cls = 'mini-cell';
                            let style = '';
                            if (cell === 'F') {
                                cls += ' cell-F';
                                style = 'background: #ff9999; color: #000; font-weight: bold;';
                            } else if (cell === 'C') {
                                cls += ' cell-C';
                                style = 'background: #9999ff; color: #000; font-weight: bold;';
                            } else if (cell === 'I') {
                                cls += ' cell-I';
                                style = 'background: #99ff99; color: #000; font-weight: bold;';
                            } else if (cell === 'X') {
                                style = 'background: #ddd; color: #666; font-weight: bold;';
                            } else {
                                style = 'background: #f0f0f0; color: #999; font-weight: bold;';
                            }

                            if (idx === 4) cls += ' conv-highlight';
                            return `<div class="${cls}" style="${style}">${cell}</div>`;
                        }).join('')}
                    </div>
                    <div>
                        Encoding: [${neighborhood.map(cell => {
                            if (cell === 'C') return '1,0,0,0';
                            else if (cell === 'F') return '0,1,0,0';
                            else if (cell === 'I') return '0,0,1,0';
                            else return '0,0,0,1';
                        }).join(', ')}]<br>
                        <span style="font-size: 11px; color: #666;">36 values for this cell's neighborhood</span>
                    </div>
                </div>
            `;
        }

        createConvInteractive();
        updateConvExample(3, 3); // Show center cell by default

        // Create improved graph visualization for Method 5
        function createGraphViz() {
            const viz = document.getElementById('graph-viz');
            viz.innerHTML = '';
            const scale = 40;

            // Create connection lines container
            const linesContainer = document.createElement('div');
            linesContainer.id = 'graph-lines';
            linesContainer.style.position = 'absolute';
            linesContainer.style.width = '100%';
            linesContainer.style.height = '100%';
            viz.appendChild(linesContainer);

            // Create nodes
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const node = document.createElement('div');
                    node.className = 'graph-node';
                    const cellType = lattice[i][j];
                    const nodeId = i * 8 + j;

                    if (cellType === 'F') {
                        node.classList.add('cell-F');
                        node.textContent = 'F';
                    } else if (cellType === 'C') {
                        node.classList.add('cell-C');
                        node.textContent = 'C';
                    } else if (cellType.startsWith('I')) {
                        node.classList.add('cell-I');
                        node.textContent = 'I';
                    }

                    node.style.left = (j * scale) + 'px';
                    node.style.top = (i * scale) + 'px';
                    node.title = `Node ${nodeId} (${i}, ${j})`;
                    node.dataset.i = i;
                    node.dataset.j = j;

                    // Add hover effect
                    node.addEventListener('mouseenter', (e) => {
                        drawConnectionLines(i, j, scale);
                        updateGraphFeatures(i, j, cellType);
                    });

                    node.addEventListener('mouseleave', () => {
                        const linesContainer = document.getElementById('graph-lines');
                        linesContainer.innerHTML = '';
                    });

                    viz.appendChild(node);
                }
            }
        }

        function drawConnectionLines(i, j, scale) {
            const linesContainer = document.getElementById('graph-lines');
            linesContainer.innerHTML = '';

            const centerX = j * scale + 15;
            const centerY = i * scale + 15;

            // Draw lines to neighbors
            const neighbors = [
                {di: -1, dj: 0}, // top
                {di: 1, dj: 0},  // bottom
                {di: 0, dj: -1}, // left
                {di: 0, dj: 1}   // right
            ];

            neighbors.forEach(({di, dj}) => {
                const ni = i + di;
                const nj = j + dj;

                if (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {
                    const line = document.createElement('div');
                    line.style.position = 'absolute';
                    line.style.background = '#ff4444';
                    line.style.transformOrigin = 'left center';

                    const targetX = nj * scale + 15;
                    const targetY = ni * scale + 15;

                    const dx = targetX - centerX;
                    const dy = targetY - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                    line.style.left = centerX + 'px';
                    line.style.top = (centerY - 1) + 'px';
                    line.style.width = distance + 'px';
                    line.style.height = '2px';
                    line.style.transform = `rotate(${angle}deg)`;

                    linesContainer.appendChild(line);
                }
            });
        }

        function updateGraphFeatures(i, j, cellType) {
            const detail = document.getElementById('graph-feature-detail');
            const examples = document.getElementById('graph-examples');

            // Calculate neighbor features
            let neighbors = [];
            let neighborTypes = [];
            if (i > 0) { neighbors.push(lattice[i-1][j]); neighborTypes.push(lattice[i-1][j]); }
            if (i < 7) { neighbors.push(lattice[i+1][j]); neighborTypes.push(lattice[i+1][j]); }
            if (j > 0) { neighbors.push(lattice[i][j-1]); neighborTypes.push(lattice[i][j-1]); }
            if (j < 7) { neighbors.push(lattice[i][j+1]); neighborTypes.push(lattice[i][j+1]); }

            const degree = neighbors.length;
            const degreeNorm = degree / 4;

            detail.innerHTML = `
                <div class="physics-calc">
                    <strong>Node at (${i},${j}) - ${cellType}:</strong><br><br>

                    1. <strong>Own features:</strong><br>
                    &nbsp;&nbsp;Type encoding: ${
                        cellType === 'C' ? '[1, 0, 0]' :
                        cellType === 'F' ? '[0, 1, 0]' :
                        '[0, 0, 1]'
                    }<br><br>

                    2. <strong>Neighbor aggregation:</strong><br>
                    &nbsp;&nbsp;Neighbors: [${neighborTypes.join(', ')}]<br>
                    &nbsp;&nbsp;Average features: [${
                        neighbors.length > 0 ?
                        [
                            neighbors.filter(n => n === 'C').length / neighbors.length,
                            neighbors.filter(n => n === 'F').length / neighbors.length,
                            neighbors.filter(n => n.startsWith('I')).length / neighbors.length
                        ].map(v => v.toFixed(2)).join(', ') : '0, 0, 0'
                    }]<br><br>

                    3. <strong>Degree centrality:</strong><br>
                    &nbsp;&nbsp;Connections: ${degree}/4 = ${degreeNorm.toFixed(2)}<br><br>

                    <strong>Total: 7 features per node × 64 nodes = 448 features</strong>
                </div>
            `;
        }

        createGraphViz();

        // Initialize graph features
        const graphDetail = document.getElementById('graph-feature-detail');
        graphDetail.innerHTML = `
            <div style="padding: 10px;">
                <strong>How Graph Encoding Works:</strong><br><br>
                • Each cell becomes a graph node<br>
                • Edges connect adjacent cells (4-connected)<br>
                • Node features combine own type + neighbor info<br>
                • Captures local connectivity patterns<br><br>
                <em>Hover over nodes to see their features!</em>
            </div>
        `;

        // Note: Method 6 (Raw 2D grid/CNN) removed from visualization as per original request

        // ========================================
        // NEW FUNCTIONALITY
        // ========================================

        // Function to show individual cell vector for Method 1
        function showIndividualCellVector(row, col, cellType) {
            const typeEncoding = cellType === 'F' ? '[1, 0, 0]' :
                                cellType === 'C' ? '[0, 1, 0]' :
                                '[0, 0, 1]';
            const posEncoding = `[${(row/7).toFixed(3)}, ${(col/7).toFixed(3)}]`;

            document.getElementById('individual-cell-vector').innerHTML = `
                <strong>Cell at (${row}, ${col}) - Type: ${cellType}</strong><br>
                Type encoding: ${typeEncoding}<br>
                Position encoding: ${posEncoding}<br>
                <strong>Full vector: [${typeEncoding.slice(1, -1)}, ${posEncoding.slice(1, -1)}]</strong>
            `;
        }

        // Function to create the interactive designer grid
        function createDesignerGrid() {
            createGrid('designer-grid', false, true);
            updateCoreConfigDisplay();
        }

        // Function to place a cell type at a position
        function placeCellType(row, col, cellType) {
            // Handle irradiation position numbering
            if (cellType === 'I') {
                const iPositions = getIPositions();
                cellType = `I${iPositions.length + 1}`;
            }

            lattice[row][col] = cellType;
            updateAllVisualizations();
            updateCoreConfigDisplay();
        }

        // Function to reset to default configuration
        function resetToDefault() {
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    lattice[i][j] = defaultLattice[i][j];
                }
            }
            updateAllVisualizations();
            updateCoreConfigDisplay();
        }

        // Function to get current I positions
        function getIPositions() {
            const positions = [];
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (lattice[i][j].startsWith('I')) {
                        positions.push({row: i, col: j, x: j + 0.5, y: i + 0.5, label: lattice[i][j]});
                    }
                }
            }
            return positions;
        }

        // Function to update core configuration display
        function updateCoreConfigDisplay() {
            let display = '';
            for (let i = 0; i < 8; i++) {
                display += lattice[i].join(' ') + '<br>';
            }
            document.getElementById('core-config-display').innerHTML = display;
        }

        // Function to show core vector encodings
        function showCoreVector(encodingType) {
            const display = document.getElementById('core-vector-display');

            if (encodingType === 'one_hot') {
                let vector = [];
                let positions = [];

                // Cell type encodings
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const cellType = lattice[i][j];
                        if (cellType === 'F') vector.push(1, 0, 0);
                        else if (cellType === 'C') vector.push(0, 1, 0);
                        else vector.push(0, 0, 1); // All I positions
                    }
                }

                // Position encodings
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        vector.push((i/7).toFixed(3), (j/7).toFixed(3));
                    }
                }

                display.innerHTML = `
                    <strong>One-Hot Encoding (${vector.length} features):</strong><br>
                    <div style="max-height: 150px; overflow-y: auto; font-family: monospace;">
                        [${vector.join(', ')}]
                    </div>
                `;

            } else if (encodingType === 'categorical') {
                let vector = [];

                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const cellType = lattice[i][j];
                        const catValue = cellType === 'C' ? 0 : cellType === 'F' ? 1 : 2;
                        const dist = Math.sqrt(Math.pow(i - 3.5, 2) + Math.pow(j - 3.5, 2)) / (3.5 * Math.sqrt(2));
                        vector.push(catValue, dist.toFixed(3));
                    }
                }

                display.innerHTML = `
                    <strong>Categorical Encoding (${vector.length} features):</strong><br>
                    <div style="max-height: 150px; overflow-y: auto; font-family: monospace;">
                        [${vector.join(', ')}]
                    </div>
                `;

            } else if (encodingType === 'physics') {
                const iPos = getIPositions();
                if (iPos.length === 0) {
                    display.innerHTML = '<em>No irradiation positions found. Add some I positions first.</em>';
                    return;
                }

                // Calculate global features
                let totalDist = 0;
                iPos.forEach(pos => {
                    totalDist += Math.sqrt(Math.pow(pos.x - 4, 2) + Math.pow(pos.y - 4, 2));
                });
                const avgDist = totalDist / iPos.length / (Math.sqrt(2) * 4);

                let sumX = 0, sumY = 0;
                iPos.forEach(pos => { sumX += pos.x; sumY += pos.y; });
                const comX = sumX / iPos.length;
                const comY = sumY / iPos.length;
                const symmetryDist = Math.sqrt(Math.pow(comX - 4, 2) + Math.pow(comY - 4, 2)) / (Math.sqrt(2) * 4);

                // Calculate local features for each I position
                let localFeatures = [];
                iPos.forEach(pos => {
                    const features = computeLocalFeaturesFromPython(pos.row, pos.col);
                    localFeatures.push(features.fuelDensity.toFixed(3), features.coolantContact.toFixed(3),
                                     features.edgeDistNorm.toFixed(3), features.centerDistNorm.toFixed(3));
                });

                // Add NCI for each position
                let nciFeatures = [];
                iPos.forEach(pos => {
                    nciFeatures.push(computeNCIForPosition(pos.row, pos.col).toFixed(3));
                });

                const physicsVector = [avgDist.toFixed(3), symmetryDist.toFixed(3), ...localFeatures, ...nciFeatures];

                display.innerHTML = `
                    <strong>Physics-Based Encoding (${physicsVector.length} features):</strong><br>
                    Global: [${avgDist.toFixed(3)}, ${symmetryDist.toFixed(3)}]<br>
                    ${iPos.map((pos, idx) => `${pos.label}: [${localFeatures.slice(idx*4, (idx+1)*4).join(', ')}] NCI: ${nciFeatures[idx]}`).join('<br>')}<br>
                    <div style="max-height: 100px; overflow-y: auto; font-family: monospace; margin-top: 5px;">
                        Full vector: [${physicsVector.join(', ')}]
                    </div>
                `;

            } else if (encodingType === 'spatial') {
                // Spatial convolution encoding
                let vector = [];

                // For each cell, encode its 3x3 neighborhood
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        // Get 3x3 neighborhood with padding
                        for (let di = -1; di <= 1; di++) {
                            for (let dj = -1; dj <= 1; dj++) {
                                const ni = i + di;
                                const nj = j + dj;

                                if (ni < 0 || ni >= 8 || nj < 0 || nj >= 8) {
                                    // Padding
                                    vector.push(0, 0, 0, 1);
                                } else {
                                    const cellType = lattice[ni][nj];
                                    if (cellType === 'C') {
                                        vector.push(1, 0, 0, 0);
                                    } else if (cellType === 'F') {
                                        vector.push(0, 1, 0, 0);
                                    } else if (cellType.startsWith('I')) {
                                        vector.push(0, 0, 1, 0);
                                    } else {
                                        vector.push(0, 0, 0, 1);
                                    }
                                }
                            }
                        }
                    }
                }

                display.innerHTML = `
                    <strong>Spatial Convolution Encoding (${vector.length} features):</strong><br>
                    <em>Each cell's 3×3 neighborhood encoded as 4-bit vectors</em><br>
                    <em>64 cells × 9 neighbors × 4 bits = 2,304 features</em><br>
                    <div style="max-height: 150px; overflow-y: auto; font-family: monospace; margin-top: 5px;">
                        [${vector.slice(0, 100).join(', ')}...]
                    </div>
                `;

            } else if (encodingType === 'graph') {
                // Graph-based encoding
                let vector = [];

                // For each cell
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const cellType = lattice[i][j];

                        // Own features
                        if (cellType === 'C') {
                            vector.push(1, 0, 0);
                        } else if (cellType === 'F') {
                            vector.push(0, 1, 0);
                        } else if (cellType.startsWith('I')) {
                            vector.push(0, 0, 1);
                        } else {
                            vector.push(0, 0, 0);
                        }

                        // Aggregate neighbor features (4-connected)
                        const neighbors = [[-1,0], [1,0], [0,-1], [0,1]];
                        let neighborCounts = [0, 0, 0]; // C, F, I counts
                        let validNeighbors = 0;

                        for (let [di, dj] of neighbors) {
                            const ni = i + di;
                            const nj = j + dj;
                            if (ni >= 0 && ni < 8 && nj >= 0 && nj < 8) {
                                validNeighbors++;
                                const neighborType = lattice[ni][nj];
                                if (neighborType === 'C') neighborCounts[0]++;
                                else if (neighborType === 'F') neighborCounts[1]++;
                                else if (neighborType.startsWith('I')) neighborCounts[2]++;
                            }
                        }

                        // Average neighbor features
                        if (validNeighbors > 0) {
                            vector.push(
                                (neighborCounts[0] / validNeighbors).toFixed(3),
                                (neighborCounts[1] / validNeighbors).toFixed(3),
                                (neighborCounts[2] / validNeighbors).toFixed(3)
                            );
                        } else {
                            vector.push(0, 0, 0);
                        }

                        // Degree centrality
                        vector.push((validNeighbors / 4).toFixed(3));
                    }
                }

                display.innerHTML = `
                    <strong>Graph-Based Encoding (${vector.length} features):</strong><br>
                    <em>Each node: [own features (3) + neighbor avg (3) + degree (1)]</em><br>
                    <em>64 nodes × 7 features = 448 features</em><br>
                    <div style="max-height: 150px; overflow-y: auto; font-family: monospace; margin-top: 5px;">
                        [${vector.slice(0, 100).join(', ')}...]
                    </div>
                `;
            }
        }

        // Function to update all visualizations when core changes
        function updateAllVisualizations() {
            createGrid('designer-grid', false, true);
            createGrid('grid1');
            createGrid('grid2', true);
            createGrid('grid3');
            createConvInteractive();
            createGraphViz();
            createRadialViz();
            createPhysicsVisualizations();
            // Update I-position selector and refresh local features
            updateIPositionSelector();
            const selector = document.getElementById('i-position-selector');
            if (selector.value && selector.value !== '') {
                updateLocalFeatures();
            } else {
                // Clear local features display if no I-positions
                document.getElementById('local-feature-metrics').innerHTML = '<div class="interactive-hint">No irradiation positions available. Add some I positions in the designer above.</div>';
            }
        }

        // Initialize the designer grid
        createDesignerGrid();

        // Make functions globally available
        window.resetToDefault = resetToDefault;
        window.showCoreVector = showCoreVector;
    </script>
</body>
</html>
